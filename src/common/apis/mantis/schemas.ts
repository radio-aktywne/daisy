// This file is auto-generated by @hey-api/openapi-ts

import * as z from "zod";

/**
 * Result
 *
 * Result of the test.
 */
export const TestResponseResultSchema = z
  .object({
    success: z.boolean().register(z.globalRegistry, {
      description: "Indicates if the test was successful.",
    }),
    message: z.string().register(z.globalRegistry, {
      description: "Message returned from the test.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Result of the test.",
  });

/**
 * Parameters
 *
 * Parameters for testing.
 */
export const ParametersSchema = z
  .object({
    message: z.optional(z.union([z.string(), z.null()])).default(null),
  })
  .register(z.globalRegistry, {
    description: "Parameters for testing.",
  });

export const TestRequestParametersSchema = z.union([
  ParametersSchema,
  z.null(),
]);

/**
 * Specification
 */
export const SpecificationSchema = z.object({
  type: z.string(),
  parameters: z.record(
    z.string(),
    z.union([
      z.record(z.string(), z.unknown()),
      z.array(z.unknown()),
      z.string(),
      z.int(),
      z.number(),
      z.boolean(),
      z.null(),
    ]),
  ),
});

/**
 * Task
 */
export const TaskSchema = z.object({
  id: z.uuid(),
  operation: SpecificationSchema,
  condition: SpecificationSchema,
  dependencies: z.record(z.string(), z.uuid()),
});

/**
 * Status
 *
 * Status of a task.
 */
export const StatusSchema = z
  .enum(["pending", "running", "cancelled", "failed", "completed"])
  .register(z.globalRegistry, {
    description: "Status of a task.",
  });

export const NaiveDatetimeSchema = z.iso.datetime({
  offset: true,
  local: true,
});

/**
 * PendingTask
 *
 * Data of a pending task.
 */
export const ScheduleResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a pending task.",
  });

/**
 * ScheduleRequestModel
 *
 * Request to schedule a task.
 */
export const ScheduleRequestDataSchema = z
  .object({
    operation: SpecificationSchema,
    condition: SpecificationSchema,
    dependencies: z.record(z.string(), z.uuid()).register(z.globalRegistry, {
      description: "Dependencies of the task.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Request to schedule a task.",
  });

/**
 * TaskIndex
 *
 * Index of tasks by status.
 */
export const ListResponseTasksSchema = z
  .object({
    pending: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of pending tasks.",
    }),
    running: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of running tasks.",
    }),
    cancelled: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of cancelled tasks.",
    }),
    failed: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of failed tasks.",
    }),
    completed: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of completed tasks.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Index of tasks by status.",
  });

/**
 * RunningTask
 *
 * Data of a running task.
 */
export const GetRunningResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
    started: NaiveDatetimeSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a running task.",
  });

export const GetRunningRequestIdSchema = z.uuid();

/**
 * GenericTask
 *
 * Data of a task of any status.
 */
export const GetResponseTaskSchema = z
  .object({
    task: TaskSchema,
    status: StatusSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a task of any status.",
  });

export const GetRequestIdSchema = z.uuid();

/**
 * PendingTask
 *
 * Data of a pending task.
 */
export const GetPendingResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a pending task.",
  });

export const GetPendingRequestIdSchema = z.uuid();

/**
 * FailedTask
 *
 * Data of a failed task.
 */
export const GetFailedResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
    started: NaiveDatetimeSchema,
    failed: NaiveDatetimeSchema,
    error: z.string().register(z.globalRegistry, {
      description: "Error message.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Data of a failed task.",
  });

export const GetFailedRequestIdSchema = z.uuid();

/**
 * CompletedTask
 *
 * Data of a completed task.
 */
export const GetCompletedResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
    started: NaiveDatetimeSchema,
    completed: NaiveDatetimeSchema,
    result: z.union([
      z.record(z.string(), z.unknown()),
      z.array(z.unknown()),
      z.string(),
      z.int(),
      z.number(),
      z.boolean(),
      z.null(),
    ]),
  })
  .register(z.globalRegistry, {
    description: "Data of a completed task.",
  });

export const GetCompletedRequestIdSchema = z.uuid();

/**
 * CancelledTask
 *
 * Data of a cancelled task.
 */
export const GetCancelledResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
    started: z.union([NaiveDatetimeSchema, z.null()]),
    cancelled: NaiveDatetimeSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a cancelled task.",
  });

export const GetCancelledRequestIdSchema = z.uuid();

/**
 * CleaningResult
 *
 * Result of cleaning.
 */
export const CleanResponseResultsSchema = z
  .object({
    removed: z.array(z.uuid()).register(z.globalRegistry, {
      description: "Identifiers of removed tasks.",
    }),
  })
  .register(z.globalRegistry, {
    description: "Result of cleaning.",
  });

/**
 * CleanRequestModel
 *
 * Request to clean tasks.
 */
export const CleanRequestDataSchema = z
  .object({
    strategy: SpecificationSchema,
  })
  .register(z.globalRegistry, {
    description: "Request to clean tasks.",
  });

/**
 * CancelledTask
 *
 * Data of a cancelled task.
 */
export const CancelResponseTaskSchema = z
  .object({
    task: TaskSchema,
    scheduled: NaiveDatetimeSchema,
    started: z.union([NaiveDatetimeSchema, z.null()]),
    cancelled: NaiveDatetimeSchema,
  })
  .register(z.globalRegistry, {
    description: "Data of a cancelled task.",
  });

export const CancelRequestIdSchema = z.uuid();

export const PingPingRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful ping.
 */
export const PingPingResponseSchema = z.void().register(z.globalRegistry, {
  description: "Successful ping.",
});

export const PingHeadpingRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Successful ping.
 */
export const PingHeadpingResponseSchema = z.void().register(z.globalRegistry, {
  description: "Successful ping.",
});

export const SseSubscribeRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Stream of Server-Sent Events.
 */
export const SseSubscribeResponseSchema = z
  .string()
  .register(z.globalRegistry, {
    description: "Stream of Server-Sent Events.",
  });

export const TasksIdCancelRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: CancelRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksIdCancelResponseSchema = CancelResponseTaskSchema;

export const TasksIdGetRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksIdGetResponseSchema = GetResponseTaskSchema;

export const TasksCleanCleanRequestSchema = z.object({
  body: CleanRequestDataSchema,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksCleanCleanResponseSchema = CleanResponseResultsSchema;

export const TasksCancelledIdGetCancelledRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetCancelledRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksCancelledIdGetCancelledResponseSchema =
  GetCancelledResponseTaskSchema;

export const TasksCompletedIdGetCompletedRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetCompletedRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksCompletedIdGetCompletedResponseSchema =
  GetCompletedResponseTaskSchema;

export const TasksFailedIdGetFailedRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetFailedRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksFailedIdGetFailedResponseSchema = GetFailedResponseTaskSchema;

export const TasksPendingIdGetPendingRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetPendingRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksPendingIdGetPendingResponseSchema =
  GetPendingResponseTaskSchema;

export const TasksRunningIdGetRunningRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: GetRunningRequestIdSchema,
  }),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksRunningIdGetRunningResponseSchema =
  GetRunningResponseTaskSchema;

export const TasksListRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Request fulfilled, document follows
 */
export const TasksListResponseSchema = ListResponseTasksSchema;

export const TasksScheduleRequestSchema = z.object({
  body: ScheduleRequestDataSchema,
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Document created, URL follows
 */
export const TasksScheduleResponseSchema = ScheduleResponseTaskSchema;

export const TestTestRequestSchema = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      parameters: z.optional(
        z.union([TestRequestParametersSchema, z.string(), z.null()]),
      ),
    }),
  ),
});

/**
 * Request fulfilled, document follows
 */
export const TestTestResponseSchema = TestResponseResultSchema;
