// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from "./client";
import {
  PingHeadpingRequestSchema,
  PingHeadpingResponseSchema,
  PingPingRequestSchema,
  PingPingResponseSchema,
  SseSubscribeRequestSchema,
  SseSubscribeResponseSchema,
  TasksCancelledIdGetCancelledRequestSchema,
  TasksCancelledIdGetCancelledResponseSchema,
  TasksCleanCleanRequestSchema,
  TasksCleanCleanResponseSchema,
  TasksCompletedIdGetCompletedRequestSchema,
  TasksCompletedIdGetCompletedResponseSchema,
  TasksFailedIdGetFailedRequestSchema,
  TasksFailedIdGetFailedResponseSchema,
  TasksIdCancelRequestSchema,
  TasksIdCancelResponseSchema,
  TasksIdGetRequestSchema,
  TasksIdGetResponseSchema,
  TasksListRequestSchema,
  TasksListResponseSchema,
  TasksPendingIdGetPendingRequestSchema,
  TasksPendingIdGetPendingResponseSchema,
  TasksRunningIdGetRunningRequestSchema,
  TasksRunningIdGetRunningResponseSchema,
  TasksScheduleRequestSchema,
  TasksScheduleResponseSchema,
  TestTestRequestSchema,
  TestTestResponseSchema,
} from "./schemas";
import type {
  PingHeadpingRequest,
  PingHeadpingResponses,
  PingPingRequest,
  PingPingResponses,
  SseSubscribeErrors,
  SseSubscribeRequest,
  SseSubscribeResponses,
  TasksCancelledIdGetCancelledErrors,
  TasksCancelledIdGetCancelledRequest,
  TasksCancelledIdGetCancelledResponses,
  TasksCleanCleanErrors,
  TasksCleanCleanRequest,
  TasksCleanCleanResponses,
  TasksCompletedIdGetCompletedErrors,
  TasksCompletedIdGetCompletedRequest,
  TasksCompletedIdGetCompletedResponses,
  TasksFailedIdGetFailedErrors,
  TasksFailedIdGetFailedRequest,
  TasksFailedIdGetFailedResponses,
  TasksIdCancelErrors,
  TasksIdCancelRequest,
  TasksIdCancelResponses,
  TasksIdGetErrors,
  TasksIdGetRequest,
  TasksIdGetResponses,
  TasksListRequest,
  TasksListResponses,
  TasksPendingIdGetPendingErrors,
  TasksPendingIdGetPendingRequest,
  TasksPendingIdGetPendingResponses,
  TasksRunningIdGetRunningErrors,
  TasksRunningIdGetRunningRequest,
  TasksRunningIdGetRunningResponses,
  TasksScheduleErrors,
  TasksScheduleRequest,
  TasksScheduleResponses,
  TestTestErrors,
  TestTestRequest,
  TestTestResponses,
} from "./types";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

class HeyApiClient {
  protected client: Client;

  constructor(args: { client: Client }) {
    this.client = args.client;
  }
}

class HeyApiRegistry<T> {
  private readonly defaultKey = "default";

  private readonly instances: Map<string, T> = new Map();

  get(key?: string): T {
    const instance = this.instances.get(key ?? this.defaultKey);
    if (!instance) {
      throw new Error(
        `No SDK client found. Create one with "new Sdk()" to fix this error.`,
      );
    }
    return instance;
  }

  set(value: T, key?: string): void {
    this.instances.set(key ?? this.defaultKey, value);
  }
}

export class Sdk extends HeyApiClient {
  public static readonly __registry = new HeyApiRegistry<Sdk>();

  constructor(args: { client: Client; key?: string }) {
    super(args);
    Sdk.__registry.set(this, args.key);
  }

  /**
   * Ping
   *
   * Ping.
   */
  public pingPing<ThrowOnError extends boolean = false>(
    options?: Options<PingPingRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      PingPingResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PingPingRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PingPingResponseSchema.parseAsync(data),
      url: "/ping",
      ...options,
    });
  }

  /**
   * Ping headers
   *
   * Ping headers.
   */
  public pingHeadping<ThrowOnError extends boolean = false>(
    options?: Options<PingHeadpingRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).head<
      PingHeadpingResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PingHeadpingRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PingHeadpingResponseSchema.parseAsync(data),
      url: "/ping",
      ...options,
    });
  }

  /**
   * Get SSE stream
   *
   * Get a stream of Server-Sent Events.
   */
  public sseSubscribe<ThrowOnError extends boolean = false>(
    options?: Options<SseSubscribeRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).sse.get<
      SseSubscribeResponses,
      SseSubscribeErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await SseSubscribeRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await SseSubscribeResponseSchema.parseAsync(data),
      url: "/sse",
      ...options,
    });
  }

  /**
   * Cancel task
   *
   * Cancel a task.
   */
  public tasksIdCancel<ThrowOnError extends boolean = false>(
    options: Options<TasksIdCancelRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      TasksIdCancelResponses,
      TasksIdCancelErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksIdCancelRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksIdCancelResponseSchema.parseAsync(data),
      url: "/tasks/{id}",
      ...options,
    });
  }

  /**
   * Get task
   *
   * Get a task.
   */
  public tasksIdGet<ThrowOnError extends boolean = false>(
    options: Options<TasksIdGetRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksIdGetResponses,
      TasksIdGetErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksIdGetRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksIdGetResponseSchema.parseAsync(data),
      url: "/tasks/{id}",
      ...options,
    });
  }

  /**
   * Clean tasks
   *
   * Clean tasks.
   */
  public tasksCleanClean<ThrowOnError extends boolean = false>(
    options: Options<TasksCleanCleanRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      TasksCleanCleanResponses,
      TasksCleanCleanErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksCleanCleanRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksCleanCleanResponseSchema.parseAsync(data),
      url: "/tasks/clean",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Get cancelled task
   *
   * Get a cancelled task.
   */
  public tasksCancelledIdGetCancelled<ThrowOnError extends boolean = false>(
    options: Options<TasksCancelledIdGetCancelledRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksCancelledIdGetCancelledResponses,
      TasksCancelledIdGetCancelledErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksCancelledIdGetCancelledRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksCancelledIdGetCancelledResponseSchema.parseAsync(data),
      url: "/tasks/cancelled/{id}",
      ...options,
    });
  }

  /**
   * Get completed task
   *
   * Get a completed task.
   */
  public tasksCompletedIdGetCompleted<ThrowOnError extends boolean = false>(
    options: Options<TasksCompletedIdGetCompletedRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksCompletedIdGetCompletedResponses,
      TasksCompletedIdGetCompletedErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksCompletedIdGetCompletedRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksCompletedIdGetCompletedResponseSchema.parseAsync(data),
      url: "/tasks/completed/{id}",
      ...options,
    });
  }

  /**
   * Get failed task
   *
   * Get a failed task.
   */
  public tasksFailedIdGetFailed<ThrowOnError extends boolean = false>(
    options: Options<TasksFailedIdGetFailedRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksFailedIdGetFailedResponses,
      TasksFailedIdGetFailedErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksFailedIdGetFailedRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksFailedIdGetFailedResponseSchema.parseAsync(data),
      url: "/tasks/failed/{id}",
      ...options,
    });
  }

  /**
   * Get pending task
   *
   * Get a pending task.
   */
  public tasksPendingIdGetPending<ThrowOnError extends boolean = false>(
    options: Options<TasksPendingIdGetPendingRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksPendingIdGetPendingResponses,
      TasksPendingIdGetPendingErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksPendingIdGetPendingRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksPendingIdGetPendingResponseSchema.parseAsync(data),
      url: "/tasks/pending/{id}",
      ...options,
    });
  }

  /**
   * Get running task
   *
   * Get a running task.
   */
  public tasksRunningIdGetRunning<ThrowOnError extends boolean = false>(
    options: Options<TasksRunningIdGetRunningRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      TasksRunningIdGetRunningResponses,
      TasksRunningIdGetRunningErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksRunningIdGetRunningRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksRunningIdGetRunningResponseSchema.parseAsync(data),
      url: "/tasks/running/{id}",
      ...options,
    });
  }

  /**
   * Get index
   *
   * List tasks.
   */
  public tasksList<ThrowOnError extends boolean = false>(
    options?: Options<TasksListRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      TasksListResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksListRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksListResponseSchema.parseAsync(data),
      url: "/tasks",
      ...options,
    });
  }

  /**
   * Schedule task
   *
   * Schedule a task.
   */
  public tasksSchedule<ThrowOnError extends boolean = false>(
    options: Options<TasksScheduleRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      TasksScheduleResponses,
      TasksScheduleErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TasksScheduleRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TasksScheduleResponseSchema.parseAsync(data),
      url: "/tasks",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Test
   *
   * Test.
   */
  public testTest<ThrowOnError extends boolean = false>(
    options?: Options<TestTestRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      TestTestResponses,
      TestTestErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TestTestRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TestTestResponseSchema.parseAsync(data),
      url: "/test",
      ...options,
    });
  }
}
